<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>D3 Test</title>
    <script src="./d3.js" charset="utf-8"></script>
    <script src="./topojson.js" charset="utf-8"></script>
    <script src="./dict.js" charset="utf-8"></script>
</head>
<style>
    .tooltip {
        position: absolute;
        width: auto;
        height: auto;
        padding: 4px;
        font: 10px sans-serif;
        color: #fff;
        background: #333;
        -webkit-box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        -moz-box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        border-radius: 4px;
        visibility: hidden;
        text-align: center;
    }

    .container {
        display: flex;
    }

    .parameter {
        display: flex;
        justify-content: center;
    }

    .play_parameter {
        display: flex;
        justify-content: center;
        width: 900;
    }

    #rim {
        fill: none;
        stroke: #999;
        stroke-width: 3px;
    }

    .second-hand {
        stroke-width: 3;

    }

    .minute-hand {
        stroke-width: 8;
        stroke-linecap: round;
    }

    .hour-hand {
        stroke-width: 12;
        stroke-linecap: round;
    }

    .hands-cover {
        stroke-width: 3;
        fill: #fff;
    }

    .second-tick {
        stroke-width: 3;
        fill: #000;
    }

    .hour-tick {
        stroke-width: 8;
        fill: #000;
    }

    .second-label {
        font-size: 12px;
    }

    .hour-label {
        font-size: 24px;
    }

    .svgframe {
        background-color: #EFF5F5;
        border: solid 1px #EFF5F5;
    }
</style>

<body>
    <div class="parameter">
        <div>
            <select id="line_select">
            </select>
        </div>
        <input type="datetime-local" id="selected_date">
        <div id="reset">
            <button id="reset-button">reset zoom</button>
        </div>
    </div>
    <script type="text/javascript">
        let container = d3.select("body").append("div").attr("class", "container");

        // //ここから時計
        var radians = 0.0174532925,
            clockRadius = 180,
            margin = 40,
            histoheight = 300
        width2 = (clockRadius + margin) * 2,
            height2 = (clockRadius + margin) * 2 + histoheight,
            hourHandLength = 2 * clockRadius / 3,
            minuteHandLength = clockRadius,
            secondHandLength = clockRadius - 12,
            secondHandBalance = 30,
            secondTickStart = clockRadius;
        secondTickLength = -10,
            hourTickStart = clockRadius,
            hourTickLength = -18;
        secondLabelRadius = clockRadius + 16;
        secondLabelYOffset = 5
        hourLabelRadius = clockRadius - 40
        hourLabelYOffset = 7;


        var hourScale = d3.scaleLinear()
            .range([0, 330])
            .domain([0, 11]);

        var minuteScale = secondScale = d3.scaleLinear()
            .range([0, 354])
            .domain([0, 59]);

        var handData = [
            {
                type: 'minute',
                value: 0,
                length: -minuteHandLength,
                scale: minuteScale
            },
        ];

        let datascale = d3.scaleLinear().domain([0, 500]).range([0, clockRadius]);

        var tooltip2 = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("position", "absolute")
            .style("padding", "5px");

        var svg2 = d3.select(".container").append("svg")
            .attr("width", width2)
            .attr("height", height2)
            .attr("class", "svgframe")
            .on("click", function (event, d) {
                if (event.target.className.baseVal != "bar") {
                    histogram.selectAll("rect").attr("fill", "#497174");
                    d3.json("../data/clockdata_all.json").then((data) => {
                        drawGraph(data, face, "all");
                    })
                }
            });

        var histogram = svg2.append('g')
            .attr('id', 'histogram')
            .attr('transform', 'translate(' + 0 + ',' + 0 + ')');

        var face = svg2.append('g')
            .attr('id', 'clock-face')
            .attr('transform', 'translate(' + (clockRadius + margin) + ',' + (clockRadius + margin + histoheight) + ')');

        function drawHistogram() {
            d3.csv("../data/jinshin-youbi.csv").then(function (data) {
                var xScale = d3.scaleBand()
                    .rangeRound([margin, width2 - margin])
                    .padding(0.1)
                    .domain(data.map(function (d) { return d.day; }));

                var yScale = d3.scaleLinear()
                    .domain([0, d3.max(data, function (d) { return d.value; })])
                    .range([histoheight - margin, margin]);

                histogram.append("g")
                    .attr("transform", "translate(" + 0 + "," + (histoheight - margin) + ")")
                    .call(d3.axisBottom(xScale));

                histogram.append("g")
                    .attr("transform", "translate(" + margin + "," + 0 + ")")
                    .call(d3.axisLeft(yScale));

                histogram.append("g")
                    .selectAll("rect")
                    .data(data)
                    .enter()
                    .append("rect")
                    .attr("class", "bar")
                    .attr("x", function (d) { return xScale(d.day); })
                    .attr("y", function (d) { return yScale(d.value); })
                    .attr("width", xScale.bandwidth())
                    .attr("height", function (d) { return histoheight - margin - yScale(d.value); })
                    .attr("fill", "#497174")
                    .on("mouseover", function (event, d) { tooltip2.style("visibility", "visible").html(d.day + "<br>" + d.value); })
                    .on("mousemove", function (d) { tooltip2.style("left", event.pageX + 20 + "px").style("top", event.pageY + "px"); })
                    .on("mouseout", function (d) { tooltip2.style("visibility", "hidden"); })
                    .on("click", function (event, d) {
                        histogram.selectAll("rect").attr("fill", "#497174");
                        d3.select(this).attr("fill", "#EB6440")
                        if (d.day == "all") {
                            d3.json("../data/clockdata_all.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        } else if (d.day == "mon") {
                            d3.json("../data/clockdata_mon.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        } else if (d.day == "tue") {
                            d3.json("../data/clockdata_tue.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        } else if (d.day == "wed") {
                            d3.json("../data/clockdata_wed.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        } else if (d.day == "thu") {
                            d3.json("../data/clockdata_thu.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        } else if (d.day == "fri") {
                            d3.json("../data/clockdata_fri.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        } else if (d.day == "sat") {
                            d3.json("../data/clockdata_sat.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        } else {
                            d3.json("../data/clockdata_sun.json").then((data) => {
                                drawGraph(data, face, d.day);
                            })
                        }
                    });
            });
        }

        function drawClock() { //create all the clock elements
            updateData();	//draw them in the correct starting position

            d3.json("../data/clockdata_all.json").then((data) => {
                drawGraph(data, face, "all");
            })


            face.selectAll('.hour-tick')
                .data(d3.range(0, 12)).enter()
                .append('line')
                .attr('class', 'hour-tick')
                .attr('x1', 0)
                .attr('x2', 0)
                .attr('y1', hourTickStart)
                .attr('y2', hourTickStart + hourTickLength)
                .attr('transform', function (d) {
                    return 'rotate(' + hourScale(d) + ')';
                });

            face.selectAll('.hour-label')
                .data(d3.range(3, 13, 3))
                .enter()
                .append('text')
                .attr('class', 'hour-label')
                .attr('text-anchor', 'middle')
                .attr('x', function (d) {
                    return hourLabelRadius * Math.sin(hourScale(d) * radians);
                })
                .attr('y', function (d) {
                    return -hourLabelRadius * Math.cos(hourScale(d) * radians) + hourLabelYOffset;
                })
                .text(function (d) {
                    return d * 2;
                });


            var hands = face.append('g').attr('id', 'clock-hands');

            face.append('g').attr('id', 'face-overlay')
                .append('circle').attr('class', 'hands-cover')
                .attr('x', 0)
                .attr('y', 0)
                .attr('r', clockRadius / 20);

            hands.selectAll('line')
                .data(handData)
                .enter()
                .append('line')
                .attr('class', function (d) {
                    return d.type + '-hand';
                })
                .attr('x1', 0)
                .attr('y1', function (d) {
                    return d.balance ? d.balance : 0;
                })
                .attr('x2', 0)
                .attr('y2', function (d) {
                    return d.length;
                })
                .attr('transform', function (d) {
                    return 'rotate(' + d.scale(d.value) + ')';
                })
                .call(
                    d3.drag()
                        .on("start", dragstart)
                        .on("drag", dragged)
                        .on("end", dragend));
        }

        function drawGraph(data, face, day) {
            face.selectAll("#graph").remove();

            var start = d3.line()
                .x(0)
                .y(0)

            if (day == "all") {
                var medline = d3.line(data)
                    .x((d, i) => { return d.median * 5 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.median * 5 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var minline = d3.line()
                    .x((d, i) => { return d.min * 5 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.min * 5 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var minline2 = d3.line()
                    .x((d, i) => { return d.min * 1 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.min * 1 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var maxline = d3.line()
                    .x((d, i) => { return d.max * 5 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.max * 5 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var quarterline = d3.line()
                    .x((d, i) => { return d.quarter * 5 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.quarter * 5 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var quarter3line = d3.line()
                    .x((d, i) => { return d.quarter3 * 5 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.quarter3 * 5 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
            } else {
                var medline = d3.line()
                    .x((d, i) => { return d.median * 20 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.median * 20 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var minline = d3.line()
                    .x((d, i) => { return d.min * 20 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.min * 20 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var minline2 = d3.line()
                    .x((d, i) => { return d.min * 1 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.min * 1 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var maxline = d3.line()
                    .x((d, i) => { return d.max * 20 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.max * 20 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var quarterline = d3.line()
                    .x((d, i) => { return d.quarter * 20 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.quarter * 20 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                var quarter3line = d3.line()
                    .x((d, i) => { return d.quarter3 * 20 * Math.cos((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
                    .y((d, i) => { return d.quarter3 * 20 * Math.sin((d.hour * 15 + d.minute * 15 / 60 - 90) * Math.PI / 180) })
            }
            var linegroup = face.append("g").attr("id", "graph")

            linegroup.append("path")
                .attr("d", start(data))
                .attr("stroke", "black")
                .attr("stroke-width", 0)
                .attr("fill", "#D6E4E5")
                .attr("class", "max")
                .transition()
                .delay(400)
                .duration(200)
                .attr("d", maxline(data));
            linegroup.append("path")
                .attr("d", start(data))
                .attr("stroke", "black")
                .attr("stroke-width", 0)
                .attr("fill", "#497174")
                .attr("class", "quarter3")
                .transition()
                .delay(300)
                .duration(200)
                .attr("d", quarter3line(data));
            linegroup.append("path")
                .attr("d", start(data))
                .attr("stroke", "black")
                .attr("stroke-width", 0)
                .attr("fill", "#EB6440")
                .attr("class", "median")
                .transition()
                .delay(200)
                .duration(200)
                .attr("d", medline(data));
            linegroup.append("path")
                .attr("d", start(data))
                .attr("stroke", "black")
                .attr("stroke-width", 0)
                .attr("fill", "#0E5E6F")
                .attr("class", "quarter")
                .transition()
                .delay(100)
                .duration(200)
                .attr("d", quarterline(data));
            linegroup.append("path")
                .attr("d", start(data))
                .attr("stroke", "black")
                .attr("stroke-width", 0)
                .attr("fill", "#EFF5F5")
                .attr("class", "min")
                .transition()
                .delay(0)
                .duration(200)
                .attr("d", minline(data));
        }

        function moveHands() {
            d3.select('#clock-hands').selectAll('line')
                .data(handData)
                .transition()
                .attr('transform', function (d) {
                    return 'rotate(' + d.scale(d.value) + ')';
                });
        }
        function updateData() {
            var t = new Date();
            handData[0].value = (t.getHours() % 12) + t.getMinutes() / 60;
        }

        function dragstart(event, d) {
        }

        function dragged(event, d) {
            const nowx = event.x;
            const nowy = event.y;
            let degree = Math.atan(nowy / nowx) * 180 / Math.PI + 90;
            if (nowx < 0) {
                degree += 180;
            }
            d3.select("." + d.type + "-hand").attr("transform", "rotate(" + degree + ")")
        }

        function dragend(event, d) {

        }

        drawHistogram();
        drawClock("all");

        d3.select(self.frameElement).style("height", height2 + "px");

        function linename_option() {
            var select = document.getElementById("line_select");
            var option = document.createElement("option");
            option.setAttribute('value', "全て");
            // option要素に値をセット
            option.innerHTML = "全て";
            // selectタグの子要素にoptionタグを追加する
            select.appendChild(option);
            Object.keys(dict).forEach(d => {
                // optionタグを作成する
                var option = document.createElement("option");
                option.setAttribute('value', d);
                // option要素に値をセット
                option.innerHTML = d;
                // selectタグの子要素にoptionタグを追加する
                select.appendChild(option);
            })
        }

        linename_option();

        var colorScale = d3.scaleOrdinal(d3.schemeSet1);
        var width = 1000;
        var height = 900;
        var scale = 1500;
        let expansion = 1;
        var svg = container.append("svg")
            .attr("class", "main")
            .attr("width", width)
            .attr("height", height);

        let information_of_accident = container.append("div")
            .attr("class", "info")
            .attr("width", 100)
            .attr("height", 200);

        var map = svg.append('g')
            .attr('id', 'map')
            .attr('transform', 'translate(' + 0 + ',' + 0 + ')')
            .on("click", clicked)

        function clicked(event, d) {
            var zoomCenter = d3.pointer(event)
            var zoom = 150
            svg.selectAll("#map")
                .transition()
                .duration(1000)
                .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + zoom + ")translate(" + -zoomCenter[0] + "," + -zoomCenter[1] + ")");
        }

        let projection = d3.geoMercator()
            .center([135, 35])
            .translate([width / 2, height / 2])
            .scale(scale);
        let geoGenerator = d3.geoPath().pointRadius(0).projection(projection);
        let wait = []
        wait.push(d3.json("./japan.topojson"))
        wait.push(d3.json("../data/allcompanies.geojson"))
        wait.push(d3.json("../data/station_only_addJinshindata.geojson"))
        wait.push(d3.csv("../data/doordate.csv"))
        wait.push(d3.csv("../data/tweets.csv"))
        Promise.all(wait).then(function (values) {

            let dateselect = document.querySelector("#selected_date");
            dateselect.addEventListener('change', (event, data) => {
                now_seconds = event.target.valueAsNumber / 1000;
                update(now_to_value(now_seconds));
            })

            let speed = document.querySelector("#speed");
            speed.addEventListener('change', (event, date) => {
                speed = event.target.valueAsNumber;
                step_time = 60 * 60 * 24 * speed;
            })


            var tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .attr("id", "maintooltip")

            var japangeo = topojson.feature(values[0], values[0].objects.japan);
            map.selectAll("path")
                .data(japangeo.features)
                .enter()
                .append("path")
                .attr("d", geoGenerator)
                .attr("stroke", "black")
                .attr("stroke-width", 0.1)
                .attr("fill", "#646464");
            values.shift();
            let csv = values.pop();
            csv = csv.reverse();
            var doordata = values.pop();
            values.forEach((d) => {
                map.selectAll("path2")
                    .data(d.features)
                    .enter()
                    .append("path")
                    .attr("class", "linepath")
                    .attr("d", geoGenerator)
                    .attr("stroke", "white")
                    .attr("fill", "none")
                    .attr("stroke-width", 0.3);

                map.selectAll("path2")
                    .data(d.features.filter(d => d.geometry.type == "Point"))
                    .join("circle")
                    .attr("cx", d => { return projection(d.geometry.coordinates)[0]; })
                    .attr("cy", d => { return projection(d.geometry.coordinates)[1]; })
                    .attr("r", 0.05)
                    .attr("class", "station")
                    .attr("stroke", "#a9ceec")
                    .attr("stroke-width", 0)
                    .attr("fill", "#a9ceec")
                    .on("mouseover", function (d, i) {
                        // ここで人身事故情報を表示できるようにする
                        if (i.properties.accidents == "NULL") {
                            tooltip.style("left", d.layerX + "px").style("top", d.clientY + "px").style("visibility", "visible").html(i.properties.name + "<br>" + "事故回数: " + 0 + "回")
                        }
                        else if (i.properties.accidents == 1) {
                            url = csv[(i.properties.index).split(", ")[0].slice(1, -1)]["url"]
                            tooltip.style("left", d.layerX + "px").style("top", d.clientY + "px").style("visibility", "visible").html(
                                i.properties.name + "<br>" + "事故回数: " + 1 + "回" + "<br>"
                                + "日時: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["date"] + "<br>"
                                + "路線名: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["line"] + "<br>"
                                + "被害状況: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["injury"] + "<br>"
                                + "ツイート数:" + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["tweets"] + "<br>"
                                + `<a href=${url}>さらに詳細へ</a>`
                            )
                        }
                        else {
                            tooltip.style("left", d.layerX + "px").style("top", d.clientY + "px").style("visibility", "visible")
                            text = i.properties.name + "<br>" + "事故回数: " + i.properties.accidents + "回" + "<br>"
                            for (let step = 0; step < i.properties.accidents; step++) {
                                let index = 0
                                if (step == 0) {
                                    index = (i.properties.index).split(",")[0].slice(1)
                                }
                                else if (step == i.properties.accidents - 1) {
                                    index = (i.properties.index).split(",")[i.properties.accidents - 1].slice(0, -1)
                                }
                                else {
                                    index = (i.properties.index).split(",")[step]
                                }
                                url = csv[index - 0]["url"]
                                text += `【事故${step + 1}】` + "<br>"
                                    + "日時: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["date"] + "<br>"
                                    + "路線名: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["line"] + "<br>"
                                    + "被害状況: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["injury"] + "<br>"
                                    + "ツイート数:" + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["tweets"] + "<br>"
                                    + `<a href=${url} target='_blank'>さらに詳細へ</a>` + "<br>"
                            }
                            tooltip.html(text)
                        }
                    })
                    .on("mouseout", function () {
                    });
            })
            let zoom = d3.zoom()
                .scaleExtent([1, 150])
                .translateExtent([[0, 0], [width, height]])
                .on('zoom', handleZoom);

            d3.select('.main').call(zoom);

            function handleZoom(d) {
                expansion = d.transform.k;
                d3.select("#maintooltip").style("visibility", "hidden");
                d3.select('#map')
                    .attr('transform', d.transform);
                d3.selectAll(".station")
                    .attr("r", Math.min(0.5, 1 / expansion * 4))
                // .attr("stroke-width",1);

                d3.selectAll(".linepath")
                    .attr("stroke-width", Math.min(0.6, 1 / expansion) * 2);
            }

            d3.select("#reset")
                .on("click", resetted);

            function resetted(event, d) {
                svg.selectAll("#map")
                    .transition()
                    .duration(1000)
                    .attr("transform", "translate(0,0)");
            }

            const start_unixTime = 1262271600; //2010/01/01
            const end_unixTime = 1668006000; //2022/11/10
            let nowunix_seconds = start_unixTime;
            let step_time = 60 * 60 * 24;
            let preunix_seconds = nowunix_seconds;

            var date = svg.append("text")
                .text(`${new Date(nowunix_seconds * 1000)}`)
                .attr("x", 600)
                .attr("y", 830)
                .attr("font-family", "Arial, Helvetica, sans-serif")
                .attr("stroke", "black");

            var slider = svg.append("g")
                .attr("class", "slider");

            slider.append("line")
                .attr("x1", 10)
                .attr("x2", width - 10)
                .attr("y1", height - 50)
                .attr("y2", height - 50)
                .attr("stroke", "grey")
                .attr("stroke-width", 5)
                .attr("stroke-linecap", "round")
                .attr("pointer-events", "stroke")
                .attr("cursor", "crosshair")
                .call(d3.drag()
                    .on("start", function () { })
                    .on("drag", function (event, d) {
                        currentValue = event.sourceEvent.clientX - 460;
                        update(currentValue);
                    }));

            var handle = slider.insert("circle", ".track-overlay")
                .attr("cx", 10)
                .attr("cy", height - 50)
                .attr("r", 7);
            let interval = 100;
            let timer;
            var playButton = d3.select("#play-button")
                .on("click", function () {
                    var button = d3.select(this);
                    if (button.text() == "Pause") {
                        clearInterval(timer);
                        // timer = 0;
                        button.text("Play");
                    } else {
                        //moving = true;
                        timer = setInterval(step, interval);
                        button.text("Pause");
                    }
                })

            var doorgraph = svg.append("g")
                .attr("class", "doorgraph")
                .attr("transform", "translate(50, 600)")
                .attr("opacity", 0.5);

            var graphwidth = width - 10;
            var graphheight = 200;

            const xscale = d3.scaleTime()
                .domain([new Date(start_unixTime * 1000), new Date("2022/11/10")])
                .range([0, graphwidth])
                .clamp(true);
            const yscale = d3.scaleLinear()
                .domain([0, d3.max(doordata, d => +d.value)])
                .range([graphheight, 0]);

            var xaxis = d3.axisBottom(xscale).ticks(5);
            var yaxis = d3.axisLeft(yscale);

            doorgraph.append("g")
                .attr("class", "xaxis")
                .attr("transform", `translate(0, ${graphheight})`)
                .call(xaxis);
            doorgraph.append("g")
                .attr("class", "yaxis")
                .attr("transform", "translate(0, 0)")
                .call(yaxis);

            var alldoor = doordata.filter(function (d) {
                return (new Date(d.date)) < (new Date(nowunix_seconds * 1000));
            })
            drawline(alldoor);

            function drawline(data) {
                var area = d3.area()
                    .x(function (d) { return xscale(new Date(d.date)); })
                    .y0(graphheight)
                    .y1(function (d) { return yscale(d.value); });

                doorgraph.selectAll("path").remove();
                doorgraph.append("path")
                    .attr("d", area(data))
                    .attr("fill", "darkgrey")
                    .attr("stroke", "grey")
                    .attr("stroke-width", 2);
            }

            function step() {
                let temp_seconds = nowunix_seconds + step_time;
                if (now_to_value(temp_seconds) >= width - 10) {
                    clearInterval(timer);
                    playButton.text("Play");
                }
                update(now_to_value(temp_seconds));
            }

            var speedButton = d3.select("#speed-button")
                .on("click", function () {
                    let button = d3.select(this);
                    if (button.text() == "x2") {
                        step_time *= 2;
                        button.text("1/2");
                    }
                    else {
                        step_time /= 2;
                        button.text("x2");
                    }
                })

            function now_to_value(now_seconds) {
                return (now_seconds - start_unixTime) * (width - 20) / (end_unixTime - start_unixTime) + 10;
            }
            function update(now_position) {
                // update position and text of label according to slider scale
                if (now_position >= 10 && now_position <= width - 10) {
                    handle.attr("cx", now_position);
                    preunix_seconds = nowunix_seconds;
                    nowunix_seconds = (end_unixTime - start_unixTime) / (width - 10 - 10) * (now_position - 10) + start_unixTime;
                    date.text(`${new Date(nowunix_seconds * 1000)}`);
                    let viewer = binary_search();
                    let count = 0;
                    let line_limit = document.getElementById('line_select');
                    for (let i = viewer[0] + 1; i <= viewer[1] && count <= 40; i++) {
                        if (line_limit.value == "全て") {
                            // 何もしない
                        }
                        else if (csv[i]["line"] != line_limit.value) {
                            continue;
                        }
                        update_draw(csv[i]["line"], csv[i]["place"], csv[i]["tweets"], csv[i]["date"], i);
                        count++;
                    }
                    var newData = doordata.filter(function (d) {
                        return (new Date(d.date)) < (new Date(nowunix_seconds * 1000));
                    })
                    drawline(newData);
                }
                //filter data set and redraw plot
            }

            function binary_search() {
                let wa = csv.length;
                let ac = 0;
                while (wa - ac > 1) {
                    let mid = parseInt((ac + wa) / 2);
                    if (new Date(csv[mid]["date"]).getTime() < nowunix_seconds * 1000) {
                        ac = mid;
                    }
                    else {
                        wa = mid;
                    }
                }
                let most_new = ac;
                wa = csv.length;
                ac = 0;
                while (wa - ac > 1) {
                    let mid = parseInt((ac + wa) / 2);
                    if (new Date(csv[mid]["date"]).getTime() < preunix_seconds * 1000) {
                        ac = mid;
                    }
                    else {
                        wa = mid;
                    }
                }
                let most_old = ac;
                return [most_old, most_new];
            }
            let placelist = [];
            function update_draw(line, place, tweets, date, i) {
                if (place.indexOf("〜") != -1) {
                    let station1 = place.slice(0, place.indexOf("〜"));
                    let station2 = place.slice(place.indexOf("〜") + 1, place.length)
                    update_draw(line, station1, tweets, date, i);
                    update_draw(line, station2, tweets, date, i);
                }
                else {
                    console.log(line);
                    if (dict[line] == undefined) {
                        return;
                    }
                    placelist.push([place, line, date]);
                    if (placelist.length > 30) {
                        placelist.shift();
                    }
                    let info_sentence = "";
                    placelist.forEach(e => {
                        let tmp_sentence = `<a href=${csv[i]["url"]} target="_blank">`;
                        let tmp_sentence2 = `${e[2]}`
                        tmp_sentence2 += ` ${e[1]}`
                        tmp_sentence2 += ` ${e[0]}`;
                        const MAX_LENGTH = 30 //文字数上限
                        if (tmp_sentence2.length >= MAX_LENGTH) {
                            tmp_sentence2 = tmp_sentence2.substr(0, MAX_LENGTH) + '...'
                        }
                        tmp_sentence += tmp_sentence2;
                        tmp_sentence += "</a><br>"
                        info_sentence += tmp_sentence;
                    })
                    information_of_accident.html(`${info_sentence} 14896件中${i}件目を表示しました`)
                    dict[line].forEach((line) => {
                        d3.json(line).then(
                            function (d) {
                                map.selectAll("path2")
                                    .data(d.features.filter(d => (d.properties.name == place.slice(0, -1))))
                                    .join("circle")
                                    .attr("cx", d => { return projection(d.geometry.coordinates)[0]; })
                                    .attr("cy", d => { return projection(d.geometry.coordinates)[1]; })
                                    .attr("r", 1)
                                    .attr("stroke", "none")
                                    .attr("fill", "red")
                                    .transition()
                                    .duration(500)
                                    .attr("r", Math.max(Math.log(tweets) * 3 / expansion, 0.1))
                                    .transition()
                                    .delay(100)
                                    .duration(100)
                                    .attr("r", 0)
                            }
                        )
                    })
                }
            }
        })
    </script>
    <div class="play_parameter">
        <div>
            <button id="play-button">Play</button>
        </div>
        <div>
            <input type="number" id="speed">倍速
        </div>
    </div>
</body>

</html>