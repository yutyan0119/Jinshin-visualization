<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>D3 Test</title>
    <script src="./d3.js" charset="utf-8"></script>
    <script src="./topojson.js" charset="utf-8"></script>
    <script src="./dict.js" charset="utf-8"></script>
</head>
<style>
    .tooltip {
        position: absolute;
        width: auto;
        height: auto;
        padding: 4px;
        font: 10px sans-serif;
        color: #fff;
        background: #333;
        -webkit-box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        -moz-box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        border-radius: 4px;
        visibility: hidden;
        text-align: center;
    }
</style>

<body>
    <div>
        <select id="line_select">
        </select>
    </div>
    <input type="datetime-local" id="selected_date">
    <div id="reset">
        <button id="reset-button">reset</button>
    </div>
    <div>
        <button id="play-button">Play</button>
    </div>
    <div>
        <button id="speed-button">x2</button>
    </div>
    <script type="text/javascript">

        function linename_option() {
            var select = document.getElementById("line_select");
            var option = document.createElement("option");
            option.setAttribute('value', "全て");
            // option要素に値をセット
            option.innerHTML = "全て";
            // selectタグの子要素にoptionタグを追加する
            select.appendChild(option);
            Object.keys(dict).forEach(d => {
                // optionタグを作成する
                var option = document.createElement("option");
                option.setAttribute('value', d);
                // option要素に値をセット
                option.innerHTML = d;
                // selectタグの子要素にoptionタグを追加する
                select.appendChild(option);
            })
        }

        linename_option();

        var colorScale = d3.scaleOrdinal(d3.schemeSet1);
        var width = 1000;
        var height = 900;
        var scale = 1500;
        let expansion = 1;
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        var map = svg.append('g')
            .attr('id', 'map')
            .attr('transform', 'translate(' + 0 + ',' + 0 + ')')
            .on("click", clicked)

        function clicked(event, d) {
            var zoomCenter = d3.pointer(event)
            var zoom = 150
            svg.selectAll("#map")
                .transition()
                .duration(1000)
                .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + zoom + ")translate(" + -zoomCenter[0] + "," + -zoomCenter[1] + ")");
        }

        let projection = d3.geoMercator()
            .center([135, 35])
            .translate([width / 2, height / 2])
            .scale(scale);
        let geoGenerator = d3.geoPath().pointRadius(0).projection(projection);
        let wait = []
        wait.push(d3.json("./japan.topojson"))
        wait.push(d3.json("../data/allcompanies.geojson"))
        wait.push(d3.json("../data/station_only_addJinshindata.geojson"))
        wait.push(d3.csv("../data/doordate.csv"))
        wait.push(d3.csv("../data/tweets.csv"))
        Promise.all(wait).then(function (values) {

            let dateselect = document.querySelector("#selected_date");
            dateselect.addEventListener('change', (event, data) => {
                now_seconds = event.target.valueAsNumber / 1000;
                update(now_to_value(now_seconds));
            })


            var tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")

            var japangeo = topojson.feature(values[0], values[0].objects.japan);
            map.selectAll("path")
                .data(japangeo.features)
                .enter()
                .append("path")
                .attr("d", geoGenerator)
                .attr("stroke", "black")
                .attr("stroke-width", 0.1)
                .attr("fill", "#646464");
            values.shift();
            let csv = values.pop();
            csv = csv.reverse();
            var doordata = values.pop();
            values.forEach((d) => {
                map.selectAll("path2")
                    .data(d.features)
                    .enter()
                    .append("path")
                    .attr("d", geoGenerator)
                    .attr("stroke", "white")
                    .attr("fill", "none")
                    .attr("stroke-width", 0.3);

                map.selectAll("path2")
                    .data(d.features.filter(d => d.geometry.type == "Point"))
                    .join("circle")
                    .attr("cx", d => { return projection(d.geometry.coordinates)[0]; })
                    .attr("cy", d => { return projection(d.geometry.coordinates)[1]; })
                    .attr("r", 0.05)
                    .attr("class", "station")
                    .attr("stroke", "#a9ceec")
                    .attr("stroke-width", 0.1)
                    .attr("fill", "#a9ceec")
                    .on("mouseover", function (d, i) {
                        // ここで人身事故情報を表示できるようにする
                        if (i.properties.accidents == "NULL") {
                            tooltip.style("left", d.layerX + "px").style("top", d.clientY + "px").style("visibility", "visible").html(i.properties.name + "<br>" + "事故回数: " + 0 + "回")
                        }
                        else if (i.properties.accidents == 1) {
                            url = csv[(i.properties.index).split(", ")[0].slice(1, -1)]["url"]
                            tooltip.style("left", d.layerX + "px").style("top", d.clientY + "px").style("visibility", "visible").html(
                                i.properties.name + "<br>" + "事故回数: " + 1 + "回" + "<br>"
                                + "日時: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["date"] + "<br>"
                                + "路線名: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["line"] + "<br>"
                                + "被害状況: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["injury"] + "<br>"
                                + "ツイート数:" + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["tweets"] + "<br>"
                                + `<a href=${url}>さらに詳細へ</a>`
                            )
                        }
                        else {
                            tooltip.style("left", d.layerX + "px").style("top", d.clientY + "px").style("visibility", "visible")
                            text = i.properties.name + "<br>" + "事故回数: " + i.properties.accidents + "回" + "<br>"
                            for (let step = 0; step < i.properties.accidents; step++) {
                                let index = 0
                                if (step == 0) {
                                    index = (i.properties.index).split(",")[0].slice(1)
                                }
                                else if (step == i.properties.accidents - 1) {
                                    index = (i.properties.index).split(",")[i.properties.accidents - 1].slice(0, -1)
                                }
                                else {
                                    index = (i.properties.index).split(",")[step]
                                }
                                url = csv[index - 0]["url"]
                                text += `【事故${step + 1}】` + "<br>"
                                    + "日時: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["date"] + "<br>"
                                    + "路線名: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["line"] + "<br>"
                                    + "被害状況: " + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["injury"] + "<br>"
                                    + "ツイート数:" + csv[(i.properties.index).split(", ")[0].slice(1, -1)]["tweets"] + "<br>"
                                    + `<a href=${url}>さらに詳細へ</a>` + "<br>"
                            }
                            tooltip.html(text)
                        }
                    })
                    .on("mouseout", function () {
                        //tooltip.style("visibility", "hidden");
                    });
            })
            let zoom = d3.zoom()
                .scaleExtent([1, 50])
                .translateExtent([[0, 0], [width, height]])
                .on('zoom', handleZoom);

            d3.select('svg').call(zoom);

            function handleZoom(d) {
                expansion = d.transform.k;
                d3.select(".tooltip").style("visibility", "hidden");
                d3.select('#map')
                    .attr('transform', d.transform);
                d3.selectAll(".station")
                    .attr("r", Math.min(1, 1 / expansion));
            }

            d3.select("#reset")
                .on("click", resetted);

            function resetted(event, d) {
                svg.selectAll("#map")
                    .transition()
                    .duration(1000)
                    .attr("transform", "translate(0,0)");
            }

            const start_unixTime = 1262271600; //2010/01/01
            const end_unixTime = 1668006000; //2022/11/10
            let nowunix_seconds = start_unixTime;
            let step_time = 60 * 60 * 24;
            let preunix_seconds = nowunix_seconds;

            var date = svg.append("text")
                .text(`${new Date(nowunix_seconds * 1000)}`)
                .attr("x", 1200)
                .attr("y", 830)
                .attr("font-family", "Arial, Helvetica, sans-serif")
                .attr("stroke", "black");

            var slider = svg.append("g")
                .attr("class", "slider");

            slider.append("line")
                .attr("x1", 10)
                .attr("x2", width - 10)
                .attr("y1", height - 50)
                .attr("y2", height - 50)
                .attr("stroke", "grey")
                .attr("stroke-width", 5)
                .attr("stroke-linecap", "round")
                .attr("pointer-events", "stroke")
                .attr("cursor", "crosshair")
                .call(d3.drag()
                    .on("start", function () { })
                    .on("drag", function (event, d) {
                        currentValue = event.sourceEvent.clientX;
                        update(currentValue);
                    }));

            var handle = slider.insert("circle", ".track-overlay")
                .attr("cx", 10)
                .attr("cy", height - 50)
                .attr("r", 7);
            let interval = 100;
            let timer;
            var playButton = d3.select("#play-button")
                .on("click", function () {
                    var button = d3.select(this);
                    if (button.text() == "Pause") {
                        clearInterval(timer);
                        // timer = 0;
                        button.text("Play");
                    } else {
                        //moving = true;
                        timer = setInterval(step, interval);
                        button.text("Pause");
                    }
                })

            var doorgraph = svg.append("g")
                .attr("class", "doorgraph")
                .attr("transform", "translate(50, 600)");

            var graphwidth = width - 10;
            var graphheight = 200;

            const xscale = d3.scaleTime()
                .domain([new Date(start_unixTime * 1000), new Date("2022/11/10")])
                .range([0, graphwidth])
                .clamp(true);
            const yscale = d3.scaleLinear()
                .domain([0, d3.max(doordata, d => +d.value)])
                .range([graphheight, 0]);

            var xaxis = d3.axisBottom(xscale).ticks(5);
            var yaxis = d3.axisLeft(yscale);

            doorgraph.append("g")
                .attr("class", "xaxis")
                .attr("transform", `translate(0, ${graphheight})`)
                .call(xaxis);
            doorgraph.append("g")
                .attr("class", "yaxis")
                .attr("transform", "translate(0, 0)")
                .call(yaxis);

            var alldoor = doordata.filter(function (d) {
                return (new Date(d.date)) < (new Date(nowunix_seconds * 1000));
            })
            drawline(alldoor);

            function drawline(data) {
                var area = d3.area()
                    .x(function (d) { return xscale(new Date(d.date)); })
                    .y0(graphheight)
                    .y1(function (d) { return yscale(d.value); });

                doorgraph.append("path")
                    .attr("d", area(data))
                    .attr("fill", "darkgrey")
                    .attr("stroke", "grey")
                    .attr("stroke-width", 2);
            }

            function step() {
                let temp_seconds = nowunix_seconds + step_time;
                if (now_to_value(temp_seconds) >= width - 10) {
                    clearInterval(timer);
                    playButton.text("Play");
                }
                update(now_to_value(temp_seconds));
            }

            var speedButton = d3.select("#speed-button")
                .on("click", function () {
                    let button = d3.select(this);
                    if (button.text() == "x2") {
                        step_time *= 2;
                        button.text("1/2");
                    }
                    else {
                        step_time /= 2;
                        button.text("x2");
                    }
                })

            function now_to_value(now_seconds) {
                return (now_seconds - start_unixTime) * (width - 20) / (end_unixTime - start_unixTime) + 10;
            }
            function update(now_position) {
                // update position and text of label according to slider scale
                if (now_position >= 10 && now_position <= width - 10) {
                    handle.attr("cx", now_position);
                    preunix_seconds = nowunix_seconds;
                    nowunix_seconds = (end_unixTime - start_unixTime) / (width - 10 - 10) * (now_position - 10) + start_unixTime;
                    date.text(`${new Date(nowunix_seconds * 1000)}`);
                    let viewer = binary_search();
                    let count = 0;
                    let line_limit = document.getElementById('line_select');
                    for (let i = viewer[0] + 1; i <= viewer[1] && count <= 20; i++) {
                        if (line_limit.value == "全て") {
                            // 何もしない
                        }
                        else if (csv[i]["line"] != line_limit.value) {
                            continue;
                        }
                        update_draw(csv[i]["line"], csv[i]["place"], csv[i]["tweets"]);
                        count++;
                    }
                    var newData = doordata.filter(function (d) {
                        return (new Date(d.date)) < (new Date(nowunix_seconds * 1000));
                    })
                    drawline(newData);
                }
                //filter data set and redraw plot
            }

            function binary_search() {
                let wa = csv.length;
                let ac = 0;
                while (wa - ac > 1) {
                    let mid = parseInt((ac + wa) / 2);
                    if (new Date(csv[mid]["date"]).getTime() < nowunix_seconds * 1000) {
                        ac = mid;
                    }
                    else {
                        wa = mid;
                    }
                }
                let most_new = ac;
                wa = csv.length;
                ac = 0;
                while (wa - ac > 1) {
                    let mid = parseInt((ac + wa) / 2);
                    if (new Date(csv[mid]["date"]).getTime() < preunix_seconds * 1000) {
                        ac = mid;
                    }
                    else {
                        wa = mid;
                    }
                }
                let most_old = ac;
                return [most_old, most_new];
            }

            function update_draw(line, place, tweets) {
                if (place.indexOf("〜") != -1) {
                    let station1 = place.slice(0, place.indexOf("〜"));
                    let station2 = place.slice(place.indexOf("〜") + 1, place.length)
                    update_draw(line, station1, tweets);
                    update_draw(line, station2, tweets);
                }
                else {
                    if (dict[line] == undefined) {
                        return;
                    }
                    dict[line].forEach((line) => {
                        d3.json(line).then(
                            function (d) {
                                map.selectAll("path2")
                                    .data(d.features.filter(d => (d.properties.name == place.slice(0, -1))))
                                    .join("circle")
                                    .attr("cx", d => { return projection(d.geometry.coordinates)[0]; })
                                    .attr("cy", d => { return projection(d.geometry.coordinates)[1]; })
                                    .attr("r", 1)
                                    .attr("stroke", "none")
                                    .attr("fill", "red")
                                    .transition()
                                    .duration(100)
                                    .attr("r", Math.max(Math.log(tweets) * 5 / expansion, 0.1))
                                    .transition()
                                    .delay(100)
                                    .duration(1000)
                                    .attr("r", 0)
                            }
                        )
                    })
                }
            }
        })




    </script>
</body>

</html>